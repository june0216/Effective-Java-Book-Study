# 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라
### ✅ 자바의 데이터 타입은 크게 두 가지
- int, double, boolean 같은 기본 타입
- String, List 같은 참조 타입

- 박싱된 기본 타입 : 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 
- int -> Integer, double -> Double, boolean -> Boolean

오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수 있지만 차이는 사라지지 않는다

### ✅ 기본 타입과 박싱된 기본 타입의 주된 차이 3개
1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이란 속성을 갖는다
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null 을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다

- 세 가지 차이 때문에 주의하지 않고 사용하면 진짜로 문제가 발생할 수 있다.

##### Integer 값을 오름차순으로 정렬하는 비교자

Integer는 그 자체로 순서가 있으니 이 비교자가 실질 적인 의미는 없지만, 아주 흥미로운 점을 하나 보여준다.

> 코드 61-1 잘못 구현된 비교자- 문제를 찾아보자!
```java
Comparator<Integer> naturalOrder =
  (i, j) ->(i<j) ? -1 : (i==j ? 0 : 1);
```

- 별다른 문제를 찾기 어렵고, 실제로 이것저것 테스트해봐도 잘 통과한다.
- CoLlections.sort에 원소 백만 개짜리 리스트와 이 비교자를 넣어 돌려도 아무 문제가 없다. 리스트에 중복이 있어도 상관없다.
- 하지만 심각한 결함이 숨어 있다. 이 결함을 눈으로 확인하고 싶다면 naturalorder.compare (new Integer(42), new Integer(42))의 값을 출력해보자.
- 두 Integer 인스턴 스의 값이 42로 같으므로 0을 출력해야 하지만, 실제로는 1을 출력한다. 즉, 첫 번째 Integer가 두 번째보다 크다고 주장한다.

#### 결함의 원인 
1. naturalorder의 첫 번째 검사(1< 1)는 잘 작동
	- 1와 j가 참조하는 오토박싱된 Integer 인스턴스는 기본 타입 값으로 변환
2. 그런 다음 첫 번째 정숫값이 두 번째 값보다 작은지를 평가
		- 만약 작지 않다면 두 번째 검사(1==1)가 이뤄진다. 
		- 두 번째 검사에서는 두 '객체 참조'의 식별성을 검사
			 - 1와 j가 서로 다른 Integer 인스턴스라면 (비록 값은 같더라도) 이 비교의 결과는 false가 되고, 비교자는 (잘못된 결과) 1을 반환 
			 - 즉, 첫 번째 Integer 값이 두 번째보다 크다는 것이다. 이처럼 (같은 객체를 비교하는 게 아니라면) 박싱된 기본 타입에 == 연산자를 사용하면 오류 일어남

### ✅ 실무에서 이와 같이 기본 타입을 다루는 비교자가 필요하다면 Comparator.naturalorder()를 사용하자. 
- 비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다 
- 이 문제를 고치려면 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한 다음, 모든 비교를 이 기본 타입 변수로 수행해야 함
  - 이렇게 하면 오류의 원인인 식별성 검사가 이뤄지지 않는다.

> 코드 61-2 문제를 수정한 비교자
```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
            int i = iBoxed, j = jBoxed; // 오토박싱
            return i < j ? -1 : (i == j ? 0 : 1);
};
```
---

> 코드 61-3 기이하게 동작하는 프로그램 - 결과를 맞혀보자!
```java
public class Unbelievable {
  static Integer i;

  public static void main(String[] args) {
    if (1 = 42)
        System.out.print in("믿을 수 없군!");
  }
}
```

이 프로그램은 "믿을 수 없군!"을 출력하지 않지만 기이한 결과를 보여준다. 
- 1==42를 검사할 때 NuLlPointerException을 던지는 것이다. 
- 원인 : 1가 int가 아닌 Integer이며, 다른 참조 타입 필드와 마찬가지로 1의 초깃값도 nuLL이라는 데 있다. 
  - 즉, 1== 42는 Integer와 int를 비교하는 것이다. 
#### 거의 예외 없이 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. 
#### 그리고 nulL 참조를 언박싱하면 NultPointerEXception이 발생한다. 이런 일은 어디서든 벌어질 수 있다. 
#### ✅ 해법 : 1를 int로 선언

---

> 코드 61-4 끔찍이 느리다! 객체가 만들어지는 위치를 찾았는가?  코드 6-3과 같음
```java
public static void main(String[] args) {
  Long sum = OL;
  for (long i = 0; i « Integer.MAX_VALUE; i++) {
    sum += 1;
  }
  System.out.println(sum);
｝
```
- 지역변수 sum을 박싱된 기본 타입으로 선언하여 느려졌다. 
- 오류나 경고 없이 컴파일되지만, 박싱과 언박싱이 반복해서 일어나 체감될 정도로 성능이 느려진다.

이번 아이템에서 다룬 세 프로그램 모두 문제의 원인은 하나다. 
### ✅ 프로그래머 가 기본 타입과 박싱된 기본 타입의 차이를 무시한 대가를 치른 것이다. 
	- 처음 두 프로그램은 실패로 이어졌고, 마지막은 심각한 성능 문제가 발생


###  ✅ 박싱된 기본 타입을 써야 하는 경우
- 적절히 쓰이는 경우가 몇 가지 있다. 
1. 컬렉션의 원소, 키, 값
	- 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다. 
2. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수
	- 자바 언어가 타입 매개변수로 기본 타입을 지원 하지 않기 때문이다. 예컨대 변수를 ThreadLocalkinta 타입으로 선언하는 건 불가능하며, 대신 ThreadLocalsInteger>를 써야 한다.
3. 리플렉션을 통해 메서드를 호출할 때
