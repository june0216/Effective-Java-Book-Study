# 아이템 44. 표준 함수형 인터페이스를 사용하라

##### 자바가 람다를 지원하면서 API를 작성하는 모범 사례가 크게 바뀌었다
- 상위 클래스의 기본 메서드를 재정의해 원하는 동작을 구현하는 템플릿 메서드 패턴의 매력이 줄었다
  - 이를 대체하는 해법은 같은 효과의 함수 객체를 받는 정적 팩터리나 생성자를 제공하는 것 -> 함수 객체를 매개변수로 받는 생성자와 메서드를 더 많이 만들기
  - 이때 함수형 매개변수 타입을 올바르게 선택해야 함
## ✅ LinkedHashMap 예시
- LinkedHashMap 클래스의 protected 메서드인 `removeEldestEntry` 를 재정의해 캐시로 사용 가능
- 맵에 새로운 키를 추가하는 `put` 메서드는 이 메서드를 호출해 true가 반환되면 맵에서 가장 오래된 원소를 제거
```java
protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
   return size() > 100;
}
```
> 잘 동작하지만 람다를 사용하면 더 좋음
- removeEldestEntry는 size()를 호출해 맵 안의 원소 수를 알아내는데, removeEldestEntry가 인스턴스 메서드라 가능
- 팩터리나 생성자를 호출할 때는 맵의 인스턴스가 존재하지 않으므로 생성자에 넘기는 함수 객체는 이 맵의 인스턴스 메서드가 아님
- 따라서 맵은 자기 자신도 함수 객체에 건네줘야 함
```java
// 불필요한 함수형 인터페이스 - 대신 표준 함수형 인터페이스를 사용하라
@FuntionalInterface interface EldestEntryRemovalFunction<K, V> {
   boolean remove(Map<K, V> map, Map.Entry<K,V> eldest);
}
```
> 잘 동작하지만 굳이 사용할 이유 없다 (자바 표준 라이브러리에 이미 같은 모양의 인터페이스가 준비되어 있음)
#### 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라
- API가 다루는 개념 수가 줄어 익히기 더 쉬워짐
- 표준 함수형 인터페이스들은 유용한 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호운용성 크게 좋아짐

--- 

## ✨ java.util.functinon 패키지의 인터페이스들

### 기본 함수형 인터페이스
| 인터페이스 | 함수 시그니처 | 예 |
|------|---|---|
|`UnaryOperator<T>`|T apply(T t)|String::toLowerCase|
|`BinaryOperator<T>`|T apply(T t1, T t2)|BigInteger::add|
|`Predicate<T>`|boolean test(T t)|Collection::isEmpty|
|`Function<T,R>`|R apply(T t)|Arrays::asList|
|`Supplier<T>`|T get()|Instant::now|
|`Consumer<T>`|void accept(T t)|System.out::println|

- 기본 인터페이스는 기본 타입인 int, long, double용으로 각 3개식 변형 생김
- Function 인터페이스에는 기본 타입을 반환하는 변형이 총 9개가 더 있음
  - 인수와 같은 타입을 반환하는 함수는 UnaryOperator이므로, Function 인터페이스의 변형은 입력과 결과 타입이 항상 다름
  - 입력, 결과 타입이 모두 기본이면 접두어로 SrcToResult를 사용
  - 나머지는 입력이 객체 참조이고 결과가 int, long, double인 변형들로, 입력을 매개변수화하고 접두어로 ToResult 사용
- 기본 함수형 인터페이스 중 3개에는 인수를 2개씩 받는 변형 존재
  - `BiPredicate<T,U>`, `BiFunction<T,U,R>`, `BiConsumer<T,U>`
- BooleanSupplier 인터페이스는 boolean 을 반환하도록 한 Supplier의 변형

#### 표준 함수형 인터페이스 대부분은 기본 타입만 지원하지만, 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 마라
- 동작은 하나, "박싱된 기본 타입 대신 기본 타입을 사용하라" 라는 조언을 위해
- 계산량이 많으면 성능이 매우 느려질 수 있음

---
#### 대부분의 상황에서 직접 작성하는 것보다 표준 함수형 인터페이스를 사용하는 것이 낫다

## ✅ 코드를 직접 작성해야 하는 경우
- 표준 인터페이스 중 필요한 용도에 맞는 것이 없을 때
- 구조적으로 동일한 표준 함수형 인터페이스가 있더라도 직접 작성해야 할 경우
  - 아주 주의해서 설계해야함

### Comparator가 독자적인 인터페이스로 살아남아야 하는 이유
1. APi에서 굉장히 자주 사용됨
2. 구현하는 쪽에서 반드시 지켜야 할 규칙 담고 있음
3. 비교자들을 변환하고 조합해주는 유용한 디폴트 메서드를 담고 있음

- 아래 특성 중 하나 이상을 만족한다면 전용 함수형 인터페이스를 구현해야 하는 건 아닌지 고민 필요
### Comparator의 특성 세 가지
- 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다
- 반드시 따라야 하는 규약이 있다
- 유용한 디폴트 메서드를 제공할 수 있다

---
### @FunctionalInterface을 사용하는 목적
- @Override를 사용하는 이유와 비슷하다
1. 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알림
2. 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일 가능하게 함
3. 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막음
#### 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하라

---
## 함수형 인터페이스를 API에서 사용할 때의 주의점
- 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안 됨
- 문제를 피하는 법 : 서로 다른 함수형 인터페이스를 같은 위치의 인수로 사용하는 다중정의를 피하는 것
