# 변경 가능성을 최소화하라

## 💚불변 클래스란?

인스턴스의 `내부 값을 수정할 수 없는` 클래스

- 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.

## 💚불변 클래스의 예시

자바 플랫폼 라이브러리

- String
- 기본 타입의 박싱된 클래스들
- BigInteger
- BigDecimal

## 💚불변 클래스의 장점

- 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며
- 오류가 생길 여지 적음
- 안전

## 💚클래스를 불변으로 만들기 위한 5가지 규칙

1) 객체의 상태를 `변경하는 메서드를 제공하지 않`는다.

흔히 스프링 배울 때 setter는 지양한다라고 배웠는데 여기서 나오는군 반갑소~



2) 클래스를 `확장할 수 없`도록 한다.

객체의 상태를 변하게 한다.

상속을 막는 대표적인 방법 → 클래스를 final로 선언  등,,

3) 모든 필드를 `final`로 선언한다.

시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법

메서드에 **`final`**, **`abstract`**, **`private`** 등의 접근 제한자와 키워드를 사용하여 메서드의 오버라이딩을 허용할지, 확장을 할 수 있을지, 접근을 제한할 것인지 등을 명시적으로 나타냅니다. 이렇게 함으로써 다른 개발자가 코드를 보거나 사용할 때, 설계자의 의도를 명확하게 파악할 수 있습니다.

새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제 없이 동작

불변 객체는 한 번 생성되면 내부 상태가 변하지 않기 때문에, 다른 스레드로 전달되더라도 그 상태가 변경되지 않습니다. 이로 인해 동기화의 필요성이 줄어들고, 멀티스레딩 환경에서의 버그 가능성이 줄어듭니다

- 멀티 스레드? → 하나의 웹 서버가 동시에 여러 클라이언트의 요청을 처리해야 할 때, 각 요청을 처리하는 데에 별도의 스레드를 할당
- 동기화? → 여러 스레드가 동일한 자원에 접근할 때, 데이터의 일관성을 유지하기 위해 동기화가 필요합니다. 자바에서는 **`synchronized`** 키워드나 **`ReentrantLock`** 등의 도구를 사용하여 동기화를 할 수 있습니다.

4) 모든 필드를 **private**으로 선언한다.

필드가 참조하는 가변 객체를 클라이언트에서 **직접 접근해 수정하는 일을 막아**준다.

기술적으로는 기본 타입 필드나 불변 객체를 참조하는 필드를 public final로만 선언해도 불변 객체가 되지만,

하지만 이 경우, 나중에 내부 구현을 변경하려면 해당 필드의 접근 제어자를 변경해야 하므로 유연성이 떨어집니다. 또한, 클래스의 사용자가 해당 필드에 의존하게 되므로 이후에 변경이 어려워질 수 있습니다.

따라서 일반적으로는 필드를 **`private`**으로 선언하고, 필요한 경우에는 getter와 setter 메서드를 통해 접근하게 하는 것이 좋습니다. 이렇게 하면 클래스의 내부 구현을 자유롭게 변경할 수 있는 유연성을 얻을 수 있습니다.

5) **자신 외에는 내부의 가변 컴포넌트에 접근할 수 없**도록 한다.

클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.

이런 필드는 절대 클래이언트가 제공한 객체 참조를 가리키게 해서는 안 되며, 접근자 매서드가 그 필드를 그대로 반환해서도 안 된다. 방어적 복사를 수행하라

### 복잡한 예시

- 불변 복소수 클래스

```jsx
public final class Complex {
	private final double re;
	private final double im;
	
	public Complex(double re, double im){
		this.re = re;
		this.im = im;
	}
	

//내부 값을 반환하는 접근자 메서드 
	public double realPart() { return re;}
	public double imaginaryPart { return im; }

//연산 메서드 -> 자기 자신은 수정하지 않고 "새로운" Complex 인스턴스"를 만들어 반환, 피연산자는 그대로
// -> 함수형 프로그래밍
	public Complex minus(Complex c){
			return new Complex(re + c.re, im + c.im);
	}
		....
	public Complex plus(Complex c){
			return new Complex(re + c.re, im + c.im);
	}

	@Override
	pulbic boolean equals(Object o){
		..
	}
	@Override
	pulbic int hashCode(){
		..
	}
	
}
```

- 함수형 프로그래밍 vs 절차적 혹은 명령어 프로그래밍
    - 함수형 프로그래밍 → 자신을 수정하지 않고 새로운 인스턴스를 반환 피연산자는 그대로이다.
    - 절차적 프로그래밍 - 메서드에서 피연산자인 자신을 수정해 자신의 상태가 변하게 된다.
- 명명 규칙
    - 전치사 사용
        - add와 같은 동사 x, plus 같은 전치사 o
    - 해당 메서드가 객체의 값을 변경하지 않는다는 사실을 강조

- 가변객체와 불변 객체의 비교
    - 불변 객체 → 프로그래머가 다른 노력을 들이지 않아도 영원히 불변으로 남음
    - 가변 객체 → 변경 가능성으로 안심하고 쓰일 수 없다.

- 불변 객체는 근본적으로 스레드에 안전하여 따로 동기화할 필요 없음
    - 불변 객체에 대해서는 그 어떤 스레도도 다른 스레드에 영향을 줄 수 없음
    - 안심하고 공유 가능
    - 한번 만든 인스턴스를 최대한 재활용하자
    - ex) 자주 쓰이는 값들을 상수 public static final로 제공하자

        ```jsx
        public static final Complex ZERO = new Complex(0,0);
        ```

- 불변 클래스는 자주 사용하는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 적정 팩터리를 제공할 수 있다.
    - ex) 박싱된 기본 타입 클래스 전부, BigInteger
    - 장점 = 메모리 사용량, 가비지 컬렉션 비용 줄어든다.

    ```jsx
    public class ImmutableClass {
        private static final Map<String, ImmutableClass> cache = new HashMap<>();
    
        private final String attribute;
    
        private ImmutableClass(String attribute) {
            this.attribute = attribute;
        }
    
        public static ImmutableClass getInstance(String attribute) {
            // 인스턴스 캐싱 로직
            if (cache.containsKey(attribute)) {
                return cache.get(attribute);
            }
            ImmutableClass newInstance = new ImmutableClass(attribute);
            cache.put(attribute, newInstance);
            return newInstance;
        }
    
        public String getAttribute() {
            return attribute;
        }
    }
    ```

    - 싱글톤 패턴과 인스턴스 캐싱

      싱글톤 패턴과 인스턴스 캐싱은 어느 정도 유사한 점이 있습니다. 둘 다 객체의 중복 생성을 피하고 한 번 생성된 인스턴스를 재사용하는 것을 목적으로 합니다. 하지만 두 패턴은 목적과 적용 범위에 차이가 있습니다.

      ### **싱글톤 패턴**

      싱글톤 패턴은 특정 클래스에 대해 하나의 인스턴스만 존재하도록 보장하는 디자인 패턴입니다. 이 패턴은 시스템 전체에서 하나의 설정 객체나 리소스 관리 객체 등을 공유할 필요가 있는 경우에 주로 사용됩니다.

      ### **인스턴스 캐싱**

      인스턴스 캐싱은 동일한 상태를 가진 불변 객체가 여러 번 요청될 경우, 이를 캐시에서 가져와서 중복 생성을 피하는 기술입니다. 즉, 같은 상태의 다수의 객체를 생성하는 것을 피합니다.

      ### **차이점**

        - **범위**: 싱글톤은 하나의 클래스에 대한 단 하나의 인스턴스만을 허용합니다. 인스턴스 캐싱은 같은 상태를 가진 객체에 대해서만 단일 인스턴스를 유지하며, 다른 상태를 가진 객체는 별도의 인스턴스를 생성할 수 있습니다.
        - **적용 대상**: 싱글톤은 불변성이 필수적이지 않지만, 인스턴스 캐싱은 불변 객체에 주로 적용됩니다.
        - **용도**: 싱글톤은 주로 전역 상태를 관리할 때 사용되며, 인스턴스 캐싱은 객체 생성 비용을 줄이고 성능을 향상시키기 위해 사용됩니다.

      따라서 두 패턴은 비슷한 목적을 가지고 있지만, 상황과 요구 사항에 따라 적절히 선택되어야 합니다.


- 불변 객체를 자유롭게 공유할 수 있다는 점 → 방어적 복사도 필요 없다.
    - 아무리 복사해봐야 원본과 똑같으니 복사 자체가 의미 없음
- 불변 객체는 자유롭게 공유할 수 있음 + 불변 객체 끼리는 내부 데이터를 공유할 수 있다.
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
    - 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하다.
    - ex) 맵의 키와 집합의 원소로 쓰기에 안성맞춤
- 불변 객체는 그 자체로 실패 원자성을 제공한다.

## 💚단점

- 값이 다르면 반드시 독립된 객체로 만들어야 한다.

    ```jsx
    String a = "Hello";
    String b = "World";
    String c = a + b;  // 새로운 String 객체가 생성됩니다.
    ```

- 원하는 객체를 완성하기까지의 단계가 많고 그 중간 단계에서 만들어진 객체들이 모두 버려진다면 성능 문제
    - 해결 방법 1
        - 라이브러리 또는 클래스 설계 단계에서 흔히 쓰일 다단계 연산들을 미리 예측하여 기본 기능으로 제공
        - pakage-private 가변 동반 클래스
    - 해결 방법 2
        - public 가변 동반 클래스
            - ex) String의 StringBuilder

## 💚불변 클래스를 만드는 기본적인 방법

- 자신을 상속 못하게 하는 방법
    - 1) final
    - 2) 더 유연한 방법 → 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공
        - *정적 팩터리? = 정적 팩터리 메서드는 클라이언트가 직접 생성자를 호출하여 객체를 생성하는 대신, 정적 메서드를 통해 객체를 생성하고 반환하는 패턴

      ```jsx
      public final class Complex {
          private final double re;
          private final double im;
          
          private Complex(double re, double im){ // 생성자를 직접 호출 못함
              this.re = re;
              this.im = im;
          }
          
      
          public static Complex valueOf(double re, double im){ // 대신 정적 메서드를 통해 객체를 생성하고 반환
                      return new Complex(re, im);
          }
      
          
      }
      ```

        - final과 다를 게 없다. → publicdlsk protected 생성자가 없으니 다른 패키지에서 이 클래스를 확장하는 게 불가능하기 때문
        - 장점 = 유연성 + 객체 캐싱 기능으로 성능 향상

- BigInteger, BigDecimal의 경우 설계할 당시 final이어야 한다는 생각이 널리 퍼지지 않았다.
    - → 이 인스턴스를 인수로 받는다면 주의
    - 객체가 신뢰할 수 있는 것인지 확인 + 방어적으로 복사하여 사용

## 💚완화된 불변 클래스

- 불변 클래스 규칙 목록에 따르면 → “모든 필드가 final “ → 과감한 느낌
    - 성능을 위해 완화할 수 있다.
        - “어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다. “
        - ex) 계산 비용이 큰 값을 처음 쓰일 때 계산하여 final이 아닌 필드에 캐시해 놓고 쓴다.

          ⇒ 이는 그 객체가 불변이기 때문에 부릴 수 있다. 몇번을 계산해도 항상 같은 결과가 만들어짐이 보장


## 💚정리

- setter를 무조건 만들지 말라
- 단순한 값 객체 (ex) phoneNumber는 항상 불변으로 만들자
- 불변으로 만들 수 없는 객체라면 변경해야할 “필드”만 뺀 나머지를 final로
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다
    - 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다. 성능 이점 없음