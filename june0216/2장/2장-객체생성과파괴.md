# 객체를 만들어야 할 때와 만들지 않아야 할 때를 구분하는 법

# 생성자 대신 정적 팩터리 메서드를 고려하라

- 클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단 = public
- 클래스는 생성자와 별도로 `정적 팩터리 메서드`를 제공
- 장점
    - 1) 이름을 가질 수 있다.
        - 정적 팩터리는 생성자에 비해 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.
            - ex) 생성자 - BigInteger(int, int, Random) vs 정적 팩터리 메서드 BigInteger.probablePrime
        -
    - 2) 호출될 떄마다 인스턴스를 새로 생성자히는 않아도 된다.
        - 불필요한 객체 생성을 피할 수 있다.
        - 언제 어느 인스턴스를 살아있게 할지를 철저히 통제할 수 있다. - 인스턴스 통제 클래스
            - 싱글턴, 인스턴스화 불가로 만들 수 있다.
            - 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다 → a==b 일 때만 a.equals(b)가 성립
    - 3) 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
        - 반환할 객체의 클래스를 자유롭게 선택할 수 있음 → 유연성
        - API를 작게 유지할 수 있다.
    - 4) 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    - 5) 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        - 프레임워크를 만드는 근간이 된다.
            - ex) JDBC - 서비스 제공자 프레임워크 = 제공자의 서비스 구현체이다.
            - 이 구현체들은 클라이언트에 제공하는 역할을 프레임워크가 통제하여 클라이언트를 구현체로부터 분리
            - 서비스 제공자 프레임워크 → 3개의 핵심 컴포넌트로 이뤄진다.
                - 1) 구현체의 동작을 정의하는 서비스 인터페이스
                - 2) 제공자가 구현체를 등록할 때 사용하는 제공자 등록 API
                - 3) 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 서비스 접근 API → 유연한 정적 팩터리
            - 3개 핵심 컴포넌트와 더불어 종종 서비스 제공자 인터페이스라는 네 번째 컴포넌트가 쓰임
                - 서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체를 설명
            - 서비스 제공자 프레임워크 패턴에는 여러 변형이 있다.
                - 브리지 패턴
                - 의존 객체 주입 프레임워크

- 단점
    - 1) 상속을 하려면 public이나 protected 생성자가 필요 → 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
    - 2) 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
        - 생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다.
        - 정적 팩터리 메서드에 흔히 사용하는 명명 방식
            - from : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 메서드
            - of : 여러 매개 변수를 받아 적합한 타입의 인스턴스를 반환하는 직계 메서드
            - valueOf : from과 of의 더 자세한 버전
            - instance(getInstance) : 매개변수로 명시한 인스턴스를 반환하지만 같은 인스턴스임을 보장하지 않는다.
            - create(newInstance) : instance(getInstance) 와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장
            - getType : instance(getInstance) 와 같으나, 생성한 클래스가 아닌 다른 클래스의 팩터리 메서드를 정의할 때 쓴다.
            - newType : newInstance와 같으나, 생성한 클래스가 아닌 다른 클래스의 팩터리 메서드를 정의할 때 쓴다.
            - type : getType과 newType의 간결한 버전

    <aside>
    💡 무조건 public 생성자를 제공하는 습관을 고치자

    </aside>


# 생성자에 매개변수가 많다면 빌더를 고려하자

- 생성자에 매개변수가 많은 생성자 혹은 정적 팩터리의 모습
    - 1) 점층적 생성자 패턴
        - 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어려움
    - 2) 자바빈즈패턴
        - 매개 변수가 없는 생성자로 객체를 만든 후 세터 메서드들을 호출해 원하는 매개 변수의 값을 설정
        - 객체 하나를 만들려면 여러 메서드를 호출해야함 + 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태
            - 일관성이 깨진다면 디버깅도 만만치 않음
            - 클래스를 불변으로 만들 수 없음
        - 이러한 단점 보완 → 객체를 수동으로 얼리고 얼리기 전에는 사용할 수 없도록 하는 방법
            - 하지만 freeze 메서드를 확실히 호출해줬는지를 컴파일러가 보증할 방법 없음 → 런타임 오류 취약
    - 3) 빌더 패턴
        - 점층적 생성자 패턴의 안정성과 자바 빈즈 패턴의 가독성을 겸비
        - 빌더는 생성할 클래스 안에 정적멤버 클래스로 만들어두는 게 보통이다.
        - 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.

# private 생성자나 열거 타입으로 싱글턴임을 보증하라

- 싱글턴 = 인스턴스를 오직 하나만 생성할 수 있는 클래스
    - ex) 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트
- 싱글턴을 만드는 방식 2가지
    - 1) 생성자는 private으로 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해둔다.

      ```java
      public class Elvis{
          pulbic static final Elvis instance = new Elvis();
          private Elvis(){ ... } 
      }
      ```

        - private 생성자는 public static final 필드를 초기화할 때 딱 한 번만 호출 → 해당 인스턴스는 전체 시스템에서 하나뿐임으로 보장한다.
        - 싱글턴임으로 API 에 명백히 드러남, 간결함
    - 2) 정적 책터리 메서드를 public static 멤버 변수로

      ```java
      public class Elvis{
          pulbic static final Elvis instance = new Elvis();
          public static Elvis getInstance() {return INSTANCE;}
          private Elvis(){ ... } 
      }
      ```

        - 항상 같은 객체의 참조를 반환
        - api 를 변경하지 않고 싱글턴이 아니게 변경할 수 있다.
    - 3) 원소가 하나인 열거 타입 방식

      ```java
      public enum Elvis{
          INSTANCE;
      }
      ```



# 인스턴스화를 막으려거든 private 생성자를 사용하라

- 정적 메서드와 정적 필드만을 담은 클래스를 만들기
- 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 게 아니다.
    - 하지만 생성자를 명시하지 않으면 자동적으로 컴파일러가 기본 생성자를 만들어준다. (public)
        - 사용자는 이 생성자가 자동 생성된 것인지 구분할 수 없다.
    - 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.
        - 하위 클래스를 만들어 인스턴스화 하면 그만이다.
- 인스턴스화를 막는 방법 = private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.
    - private이므로 바깥에서 접근할 수 없다.

# 자원을 직접 명시하지 말고 의존 객체 주입을 사용

- 많은 클래스가 하나 이상의 자원에 의존한다.
- 정적 유틸리티를 잘못 사용한 예
    - 사전에 맞춤법 검사기가 의존하는 경우
        - 1)

          ```java
            public SpellChecker{
              private static final Lexion dictionary;
              private SpellChecker(){}
            }
          ```

        - 2) 싱글턴

          ```java
          public SpellChecker{
              private static final Lexion dictionary;
              private SpellChecker(){}
              public static SpellChecker INSTANCE = new SpellChecker();
          }
          ```

        - ⇒ 유연하지 않고 테스트하기 어렵

- 사용자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 ㅇ낳다.
    - → “인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨준다”는 것으로 해결

    ```java
    public SpellChecker{
    	private final Lexion dictionary;
    	public SpellChecker(Lexicon dictionary){
    			this.dictionary = Objects.requireNonNull(dictionary);
    		}
    	public static SpellChecker INSTANCE = new SpellChecker();
    }
    ```

- 의존 객체 주입 패턴
- 의존 객체 주입 패턴의 변형 → 생성자에 자원 팩터리를 넘겨주는 방식
    - 팩터리 메서드 패턴 - 호출할 떄마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체
        - ex) Supplier<T> 인터페이스
            - Supplier<T>를 입력으로 받는 메서드는 일반적으로 한정적 와일드카드 타입을 사용해 팩터리 타입 매개 변수를 제한해야 한다.
            - 이 방식을 사용해 클라이언트는 자신이 명시한 타입의 하위 타입이라면 무엇이든 생성할 수 있는 팩터리를 넘길 수 있다.

<aside>
💡 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다. → 대신 필요한 자원을 생성자에 넘겨주자

</aside>

# 불필요한 객체 생성을 피하라

- 예시1) String.matches

  한 번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 된다. 따라서 정규표현식을 표현하는 Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해두고 사용하자 (불변객체는 안전함이 명백)

    ```java
    private static final Pattern ROMAN = Pattern.complie("(정규표현식)$");
    static boolean isRoman(String s){
    	return ROMAN.matcher(s).matches();
    }
    ```

- 예시 2) 오토박싱

  기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술임

  오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만 완전히 없애주는 것은 아니다.

  → 박싱된 기본 타입보다는 기본 타입을 사용하고 의도치 않은 오토박싱이 숨어들지 않도록 주의


# 다 쓴 객체 참조를 해제하라

- 가비지컬렉션 언어에서는 메모리 누수를 찾기가 아주 까다롭다.
    - 해법 = 해당 참조를 다 썼을 때 Null 처리
- 캐시 역시 메모리 누수를 일으키는 주범
    - 해법 = WeakHashMap을 사용해 캐시를 만들자 → 다쓴 엔트리는 그 즉시 자동으로 제거될 것이다.
- 리스너 혹은 콜백
    - 명확하게 해지까지 해주자
    - 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거해간다.
    - WeakHashMap에 key로 저장

# finalizer와 cleaner 사용을 피하라

- 두 가지 객체 소멸자를 사용
    - finalizer - 예측할 수 없고 상황에 따라 위험할 수 있어 불필요
    - cleaner는 finalizer보다 덜 위험하지만 여전히 예측할 수 없고 느리고 일반적으로 불필요함
- 대체
    - AutoCloseable을 구현해주고 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드 호출
- finalizer와 cleaner 쓰는 경우
    - 1) 안전망 역할
    - 2) 네이티브 피어와 연결된 객체
        - 네이티브 피어 → 가비지 컬렉터는 그 존재를 알 수 없다.

# try-finally 보다는 try-with-resource를 사용하라

- 자바 라이브러리에서 close 메서드를 호출해 직접 닫아줘야 하는 자원들이 많다.
- 전통적으로 자원이 제대로 닫힘을 보장하는 수단으로 try-finally가 쓰였다.
    - 하지만 디버깅 어렵, 두 번째 예외가 첫 번째 예외를 집어 삼키는 문제
- try-with-resource
    - 해당 자원이 AutoCloseable 인터페이스를 반드시 구현
    - 자바 라이브러리와 서드파티 라이브러리들의 수많은 클래스와 인터페이스가 이미 이를 구현하거나 확장함
    - 다수의 예외를 처리하기 위해 catch 절 함께 사용

    ```java
    static String firstLineOfFile(String path, String defaultVal){
    	try(BufferedReader br = new BufferedReader(
    			new FileReader(path))){
    				return br.readLine();}
    			catch (IOException e){
    				return defaultVal;
    		}
    }
    ```
